package pt.ipt.walkingsensor

import android.graphics.Point
import android.graphics.Rect
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.Bundle
import android.view.View
import android.widget.ImageView
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import pt.ipt.WalkingSensorGame.R
import java.lang.Math.floor
import kotlin.math.floor
import kotlin.properties.Delegates

//Para duvidas verificar no video https://www.youtube.com/watch?v=xcsuDDQHrLo&ab_channel=Indently


class Level1 : AppCompatActivity(), SensorEventListener {


    private lateinit var walkableMatrix: Array<Array<Int>>
    private lateinit var sensorManager: SensorManager
    private lateinit var character: ImageView
    private lateinit var mainGame: ImageView
    private lateinit var texto: TextView
    private var BaseX: Int = 0
    private var BaseY: Int = 0
    private var unitX: Float? = null
    private var unitY: Float? = null

    private var screenWidth: Float = 0F
    private var screenHeight: Float = 0F
    private val smoothness = 0.2f
    private val sensitivity = 6f


    // Baseline variables
    private var baselineSides: Float = 0f
    private var baselineUpdown: Float = 0f

    // Flag to track whether it's the first time
    private var isFirstTime = true

    private fun stringToArray(input: String): Array<Array<Int>> {
        val cleanedInput = input.replace("\n", "")
        val lines = cleanedInput.trim().substring(2, cleanedInput.length - 2).split("], [")
        val result = Array(lines.size) { Array(0) { 0 } }

        for ((i, line) in lines.withIndex()) {
            val values = line.split(", ")
            result[i] = Array(values.size) { values[it].toInt() }
        }

        return result
    }

    override fun onResume() {
        super.onResume()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_level1)

        character = findViewById(R.id.character)
        mainGame = findViewById(R.id.IslandsImageView)
        texto = findViewById(R.id.texto)

        //Init temporario, vem da API
        val input = """[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 
0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]""".trimIndent()
        walkableMatrix = stringToArray(input)


        init()
    }

    private fun setupMainGame(){


        mainGame.post {
            val mainGameLocation = IntArray(2)

            println(" mainGame : "+mainGame.x.toString()+", "+ mainGame.y)
            println(" Screen : $screenWidth, $screenHeight")
            mainGame.getLocationInWindow(mainGameLocation)
            BaseX = mainGameLocation[0]
            BaseY = mainGameLocation[1]

        }

    }
    private fun init(){
        // Get screen dimensions
        val display = windowManager.defaultDisplay
        val size = Point()
        display.getSize(size)

        screenWidth = size.x.toFloat()
        screenHeight = size.y.toFloat()
        setupMainGame()


        character.post{

            //Definir tiles
            unitX = (character.width/2f)
            unitY = (character.height/2f)

            //Cordenadas teste
            val cordX = 13
            val cordY = 34

            //Desvios para centrar
            val desvioX = character.width/(1/3f)
            val desvioY = character.height*(2/3f)

            val valX =getXCordOnScreen(cordX)
            val valY =getYCordOnScreen(cordY)

            character.x = valX*1f
            character.y = valY*1f

            // Debugging
            println("startX: $valX, startY: $valY")

            // Setup character Position
            character.visibility = View.VISIBLE

        }

        // Initialize sensors
        setupSensors()
    }
    private fun setupSensors() {
        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager

        sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)?.also {
            sensorManager.registerListener(
                this,
                it,
                SensorManager.SENSOR_DELAY_GAME,
            )
        }
    }

    override fun onSensorChanged(event: SensorEvent?) {
        if (event?.sensor?.type == Sensor.TYPE_ACCELEROMETER) {
            val sides = -event.values[0]
            val updown = event.values[1]

            if (isFirstTime) {
                // Capture baseline values on the first sensor change event
                captureBaseline(updown, sides)
                isFirstTime = false
            }

            if (unitX != null && unitY != null){
                val adjustedSides = (sides - baselineSides) * sensitivity
                val adjustedUpdown = (updown - baselineUpdown) * sensitivity

                val targetX = character.translationX + adjustedSides
                val targetY = character.translationY + adjustedUpdown

                // Limit character position to the screen boundaries
                //character.translationX = character.translationX.coerceIn(0f, mainGame.width.toFloat())
                //character.translationY = character.translationY.coerceIn(0f, mainGame.height.toFloat())

                //Check for colisions
                if(!isCollidingWithWall(targetX, targetY)) {

                    // If no collision, update the character's position with smoothness
                    character.translationX = lerp(character.translationX, targetX, smoothness)
                    character.translationY = lerp(character.translationY, targetY, smoothness)

                    // Limit character position to the screen boundaries
                    character.translationX = character.translationX.coerceIn(0f, mainGame.width.toFloat() - character.width)
                    character.translationY = character.translationY.coerceIn(0f, mainGame.height.toFloat() - character.height)

                }

                texto.text = "up/down ${adjustedUpdown.toInt()}\nleft/right ${adjustedSides.toInt()}"

            }
        }
    }

    private fun getXCordOnScreen(x: Int): Float{
        return ((screenWidth - mainGame.width  )/2) + unitX!!.times(x)
    }
    private fun getYCordOnScreen(y: Int): Float{
        return ((screenHeight - mainGame.height)/2f) + unitY!!.times(y)
    }

    private fun getXCord(valX: Float): Float{
        val x0 = ((screenWidth - mainGame.width)/2)
        return floor((valX -x0)/ unitX!!)
    }

    private fun getYCord(valY: Float) : Float{
        val y0 = (screenHeight - mainGame.height)/2
        return floor((valY - y0) / unitY!!)
    }

    private fun captureBaseline(updown: Float, sides: Float) {
        baselineSides = sides
        baselineUpdown = updown
    }

    private fun isCollidingWithWall(targetX: Float, targetY: Float): Boolean {
        //Get player location and cords
        val characterLocation = IntArray(2)
        val characterLocation2 = IntArray(2)
        character.getLocationInWindow(characterLocation)
        character.getLocationOnScreen(characterLocation2)

        if(characterLocation[0]<0 || characterLocation[1]<0){
            return  true
        }
        val valX = characterLocation[0]*1f
        val valY = characterLocation[1]*1f
        val cordX = getXCord(valX)
        val cordY = getYCord(valY)

        println("Cords : $cordX, $cordY.")

        //Get player orientation and next cordXY
        val playerOriX = (targetX / (character.width*1f/2f)).toInt()
        val playerOriY = (targetY / (character.height*1f/2f)).toInt()
        println("orientation : $playerOriX, $playerOriY.")

        //Check if next walkable[cordXY] is 1


        return false // No collision with any wall
    }

    private fun lerp(start: Float, stop: Float, amount: Float): Float {
        return start + amount * (stop - start)
    }

    override fun onAccuracyChanged(p0: Sensor?, p1: Int) {
        // Not necessary to implement
    }

    override fun onDestroy() {
        sensorManager.unregisterListener(this)
        super.onDestroy()
    }
}
